// Partially generated by fl2rust
#[macro_use]
extern crate lazy_static;
extern crate regex;

use fltk::*;
use regex::Regex;
use std::cell::RefCell;
use std::rc::Rc;

lazy_static! {
    static ref RE: Regex = Regex::new(r"([A-z]+), ([A-z]+)").unwrap();
}

#[derive(Debug, Clone, Default)]
pub struct UserInterface {
    pub create_but: button::Button,
    pub update_but: button::Button,
    pub delete_but: button::Button,
    pub pref: input::Input,
    pub br: browser::Browser,
    pub name: input::Input,
    pub surname: input::Input,
}

impl UserInterface {
    pub fn make_window() -> Self {
        let mut win = window::Window::new(397, 214, 540, 280, "");
        win.end();
        win.show();
        let create_but = button::Button::new(61, 221, 80, 35, "Create");
        win.add(&create_but);
        let update_but = button::Button::new(156, 222, 80, 35, "Update");
        win.add(&update_but);
        let delete_but = button::Button::new(251, 221, 80, 35, "Delete");
        win.add(&delete_but);
        let pref = input::Input::new(130, 22, 111, 25, "Filter Prefix:");
        win.add(&pref);
        let br = browser::Browser::new(45, 65, 210, 125, "");
        win.add(&br);
        let name = input::Input::new(380, 65, 111, 25, "Name:");
        win.add(&name);
        let surname = input::Input::new(381, 107, 111, 25, "Surname:");
        win.add(&surname);
        Self {
            create_but,
            update_but,
            delete_but,
            pref,
            br,
            name,
            surname,
        }
    }
}

fn main() {
    let mut list = vec![];
    list.push(("Hans".to_string(), "Emil".to_string()));
    list.push(("Max".to_string(), "Mustermann".to_string()));
    list.push(("Roman".to_string(), "Tisch".to_string()));
    let app = app::App::default().with_scheme(app::Scheme::Gtk);
    let ui = UserInterface::make_window();
    let mut pref = ui.pref;
    let mut br = ui.br;
    let name = ui.name;
    let surname = ui.surname;
    let mut create = ui.create_but;
    let mut update = ui.update_but;
    let mut delete = ui.delete_but;
    update.deactivate();
    delete.deactivate();

    br.set_type(browser::BrowserType::Hold);
    for elem in &list {
        br.add(&format!("{}, {}", elem.1, elem.0));
    }
    pref.set_trigger(CallbackTrigger::Changed);

    let list_rc = Rc::from(RefCell::from(list));

    pref.set_callback2({
        let list = list_rc.clone();
        let mut br = br.clone();
        move |p| {
            if p.value().is_empty() {
                br.clear();
                for elem in &*list.borrow() {
                    br.add(&format!("{}, {}", elem.1, elem.0));
                }
            } else {
                br.clear();
                for elem in &*list.borrow() {
                    if elem.1.contains(&p.value()) {
                        br.add(&format!("{}, {}", elem.1, elem.0));
                    }
                }
            }
        }
    });

    br.set_callback2({
        let name = name.clone();
        let surname = surname.clone();
        let mut upd = update.clone();
        let mut del = delete.clone();
        move |b| {
            let val = b.value();
            if let Some(n) = b.text(val) {
                let caps = RE.captures(&n).unwrap();
                name.set_value(&caps.get(2).unwrap().as_str());
                surname.set_value(&caps.get(1).unwrap().as_str());
                upd.activate();
                del.activate();
            } else {
                name.set_value("");
                surname.set_value("");
                upd.deactivate();
                del.deactivate();
            }
        }
    });

    create.set_callback({
        let mut br = br.clone();
        let list = list_rc.clone();
        let name = name.clone();
        let surname = surname.clone();
        move || {
            if !name.value().is_empty() && !surname.value().is_empty() {
                let n = name.value();
                let s = surname.value();
                list.borrow_mut().push((n, s));
                br.clear();
                for elem in &*list.borrow() {
                    br.add(&format!("{}, {}", elem.1, elem.0));
                }
            }
        }
    });

    update.set_callback({
        let mut br = br.clone();
        let list = list_rc.clone();
        move || {
            let idx = br.value() - 1;
            list.borrow_mut()[idx as usize] = (name.value(), surname.value());
            br.clear();
            for elem in &*list.borrow() {
                br.add(&format!("{}, {}", elem.1, elem.0));
            }
        }
    });

    delete.set_callback(move || {
        let idx = br.value() - 1;
        list_rc.borrow_mut().remove(idx as usize);
        br.clear();
        for elem in &*list_rc.borrow() {
            br.add(&format!("{}, {}", elem.1, elem.0));
        }
    });

    app.run().unwrap();
}
